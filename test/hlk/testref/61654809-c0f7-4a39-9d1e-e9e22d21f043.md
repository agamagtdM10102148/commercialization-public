---
title: Optical Logo Test - DVD-RW RO
description: Optical Logo Test - DVD-RW RO
MSHAttr:
- 'PreferredSiteName:MSDN'
- 'PreferredLib:/library/windows/hardware'
ms.assetid: 517b3d25-1992-4504-8ed8-d57d7eff0b19
author: dawn.wood
ms.author: dawnwood
ms.date: 11/05/2018
ms.topic: article


---

# <span id="p_hlk_test.61654809-c0f7-4a39-9d1e-e9e22d21f043"></span>Optical Logo Test - DVD-RW RO


This test validates that the optical device complies with standards and meets the Windows optical drive requirements.

## Test details

|||
|---|---|
| **Specifications**  | <ul><li>Device.Storage.Optical.CdRawRecording</li><li>Device.Storage.Optical.CommandPerformance</li><li>Device.Storage.Optical.DriveDefinition</li><li>Device.Storage.Optical.Features</li><li>Device.Storage.Optical.Profiles</li><li>Device.Storage.Optical.RealTimeStreaming</li><li>Device.Storage.Optical.MmcVersion</li><li>Device.Storage.Optical.Sata.AsynchronousNotification</li></ul> |  
| **Platforms**   | <ul><li>Windows 10, client editions (x86)</li><li>Windows 10, client editions (x64)</li><li>Windows Server 2016 (x64)</li></ul> |
| **Supported Releases** | <ul><li>Windows 10</li><li>Windows 10, version 1511</li><li>Windows 10, version 1607</li><li>Windows 10, version 1703</li><li>Windows 10, version 1709</li><li>Windows 10, version 1803</li><li>Next update to Windows 10</li></ul> |
|**Expected run time (in minutes)**| 120 |
|**Category**| Scenario |
|**Timeout (in minutes)**| 7200 |
|**Requires reboot**| false |
|**Requires special configuration**| false |
|**Type**| automatic |



## <span id="Additional_documentation"></span><span id="additional_documentation"></span><span id="ADDITIONAL_DOCUMENTATION"></span>Additional documentation


Tests in this feature area might have additional documentation, including prerequisites, setup, and troubleshooting information, that can be found in the following topic(s):

-   [Device.Storage additional documentation](device-storage-additional-documentation.md)

## <span id="Running_the_test"></span><span id="running_the_test"></span><span id="RUNNING_THE_TEST"></span>Running the test


Before you run the test, complete the test setup as described in the test requirements: [Optical Disk Drive Testing Prerequisites](optical-disk-drive-testing-prerequisites.md).

The test shows a configuration dialog box to get the primary and secondary drive tray configuration. The user has to select the identical secondary drive from the drives list in the Writer Drive dialog box and should select the drive tray capabilities, whether it supports auto ejecting and auto loading the tray.

> [!NOTE]
> 
> The I/O intensive applications running on the test computer might interfere with the optical logo test performance measurement scenarios. Please make sure there are no other applications running on the test computer when the test is running.



## <span id="Troubleshooting"></span><span id="troubleshooting"></span><span id="TROUBLESHOOTING"></span>Troubleshooting


For generic troubleshooting of HLK test failures, see [Troubleshooting Windows HLK Test Failures](../user/troubleshooting-windows-hlk-test-failures.md).

For troubleshooting information, see [Troubleshooting Device.Storage Testing](troubleshooting-devicestorage-testing.md).

The following are known issues regarding this test:

-   Bus reset test scenario disabled by default.

    By default, the test does not validate the proper device behavior upon bus reset.

    If bus reset happens, the drive is expected to reset itself properly, come back online, and should work as normal. Some defective drives do not reset themselves properly and will not work after the bus reset. This is not a proper implementation. When this specific test scenario is enabled, the command verification test cases (both device and profile test cases) send the commands with incorrect SRB data direction flag. This will typically stall the bus and eventually cause the port driver to reset the bus after a given timeout period.

    Most storage controllers do not support this test scenario properly. The incorrectly implemented storage controllers will not recover after the bus reset. If that happens, the test case might fail due to the storage controller even if the device was properly implemented. This test is not able to distinguish device failures from storage controller failures. So, testing this specific scenario is disabled by default. To enable testing this specific scenario, the test executable should be ran with the "RunDataDirectionFlagScenario" command-line option.

## <span id="More_information"></span><span id="more_information"></span><span id="MORE_INFORMATION"></span>More information


The drive shall support the following commands:

-   Get Configuration (with no media)

-   Get Event Status Notification

-   Inquiry

-   Mechanism Status

-   Mode Sense

-   Prevent Allow Medium Removal

-   Request Sense

-   Start Stop Unit

-   Test Unit Ready

The drive shall support the following commands if they are mandatory for the features and profiles it supports.

-   Get Configuration (with media)

-   Get Performance

-   Read Buffer Capacity

-   Read Capacity

-   Read Disc Information

-   Read Format Capacities

-   Read Toc Pma Atip

-   Send Opc Information

-   Set CD Speed

-   Read10

The drive shall support the following scenarios if the commands associated with these scenarios are mandatory for the features and profiles it supports.

-   Event Status Notification

-   Write

    -   Sequential mode

    -   Packet mode

    -   Restricted Overwrite

    -   Multi Session support

-   Audio Media (Write Audio Tracks)

-   Blank

-   Unique drive serial number

-   Real-time streaming

-   Audio Media Gapless Raw Recording

Test cases are segregated into the following three groups:

-   Device test cases. The following commands verification test cases that are applicable for the device:

    -   GET CONFIGURATION (WITH NO MEDIA)

    -   GET EVENT STATUS NOTIFICATION

    -   INQUIRY

    -   MECHANISM STATUS

    -   MODE SENSE

    -   PREVENT ALLOW MEDIUM REMOVAL

    -   REQUEST SENSE

    -   START STOP UNIT

    -   TEST UNIT READY

-   Profile test cases. The following commands verification test cases will be tested on all applicable profiles:

    -   GET CONFIGURATION

    -   GET PERFORMANCE

    -   READ CAPACITY

    -   READ BUFFER CAPACITY

    -   READ DISC INFORMATION

    -   READ FORMAT CAPACITIES

    -   READ TOC PMA ATIP

    -   SEND OPC INFORMATION

    -   SET CD SPEED

    -   READ10

-   Usage scenario test cases. The following scenarios are tested using the IMAPI burn engine interfaces:

    -   EVENT STATUS NOTIFICATION

    -   BLANK

    -   WRITE/MULTISESSION

    -   AUDIO MEDIA

    -   WRITE DUAL LAYER MEDIA

    -   DRIVE SERIAL NUMBER

    -   READ ONLY DRIVE

    -   REAL-TIME STREAMING

    -   AUDIO MEDIA GAPLESS RAW RECORDING

This test includes the following test cases:

-   GET CONFIGURATION COMMAND (WITH NO MEDIA)

-   GET EVENT STATUS NOTIFICATION COMMAND

-   INQUIRY COMMAND

-   MECHANISM STATUS COMMAND

-   MODE SENSE COMMAND

-   PREVENT ALLOW MEDIUM REMOVAL COMMAND

-   REQUEST SENSE COMMAND

-   START STOP UNIT COMMANDS, EJECT & LOAD PERFORMANCE

-   TEST UNIT READY COMMAND

-   GET CONFIGURATION COMMAND

-   GET PERFORMANCE

-   READ CAPACITY COMMAND

-   READ BUFFER CAPACITY COMMAND

-   READ DISC INFORMATION COMMAND

-   READ FORMAT CAPACITIES COMMAND

-   READ TOC/PMA/ATIP COMMAND

-   SEND OPC INFORMATION COMMAND

-   SET CD SPEED COMMAND

-   READ10 COMMAND

-   EVENT NOTIFICATION

-   WRITE TESTS

-   AUDIO MEDIA (WRITE AUDIO TRACKS)

-   BLANK

-   WRITE DUAL LAYER MEDIA

-   READ ONLY DRIVE

-   DRIVE SERIAL NUMBER

-   REAL TIME STREAMING

-   WRITE SPEED MEASUREMENT

-   AUDIO MEDIA GAPLESS RAW RECORDING

### <span id="GET_CONFIGURATION_command__with_no_media_"></span><span id="get_configuration_command__with_no_media_"></span><span id="GET_CONFIGURATION_COMMAND__WITH_NO_MEDIA_"></span>GET CONFIGURATION command (with no media)

**Description:** This test is to ensure the drive responds to the GET CONFIGURATION command properly when there is no media in the tray.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Eject the tray by sending the START STOP UNIT command.

2.  Wait until the tray is open.

3.  Send the GET CONFIGURATION command with response data length of 4 bytes to get the feature header data length. If the command fails, print the sense key and fail the test case. Purpose: allow software to probe support of command.

4.  Check if the drive reports no current profile in the feature header. If the drive does not repro current profile as "no current profile" then fail the test case.

5.  Send the GET CONFIGURATION command again with RT=00b and with the correct data length returned by the device in step 3. Purpose: allow software to retrieve the entire list of features supported by the drive.

6.  Check if the drive reports no current profile in the feature header. If the drive does not repro current profile as "no current profile" then fail the test case.

7.  Get the profile list feature descriptor in the response for the current profile bit set and Fail the test case if any of the profile descriptor has the current profile bit set to 1.

8.  Send the GET CONFIGURATION command with response data length of 20 bytes, RT=01b, Starting Feature Number=0010h (Random Readable Feature). If the command fails or if the Random Readable Feature descriptor is not returned, print the sense key as appropriate and fail the test case. Purpose: allow software to probe specific feature currency (not current).

9.  \[Optional\] Send the GET CONFIGURATION command with data direction flag set to "to the device" and with response data length of 4 bytes to get the feature header data length. If the command fails, print the sense key and fail the test case. Purpose: To make sure the device handles command with incorrect data direction.

10. Inject the tray.

11. Wait until the device comes to ready state

12. Send the GET CONFIGURATION command with response data length of 16 bytes, RT=01b, Starting Feature Number=0003h (Removable Medium Feature). If the command fails print the sense key as appropriate and fail the test case. If the command succeeds:

    -   Check if the "Eject" bit is set if the drive supports auto eject mechanism.

    -   Check if the "Load" bit is set if the drive supports auto inject mechanism.

**Result:** The drive should respond to the GET CONFIGURATION command properly

### <span id="GET_EVENT_STATUS_NOTIFICATION_command"></span><span id="get_event_status_notification_command"></span><span id="GET_EVENT_STATUS_NOTIFICATION_COMMAND"></span>GET EVENT STATUS NOTIFICATION command

**Description:** To validate if the drive supports the GET EVENT STATUS NOTIFICATION command

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send Get Event Status Notification Command with the following values in the CDB.

    -   Notification Class Request = 0x7E (Operational Change, Power Management, External Request, Media, Multi-Host, Device Busy),

    -   Polled = 1

    -   Allocation Length equal to the size of the response header (4 bytes)

2.  If the command fails, fail the test case

3.  In the response check which events are supported

4.  \[Optional\] Send Get Event Status Notification Command with the data direction flag set to "to the device" and the following values in the CDB.

    -   Notification Class Request = 0x7E (Operational Change, Power Management, External Request, Media, Multi-Host, Device Busy),

    -   Polled = 1

    -   Allocation Length equal to the size of the response header (4 bytes)

5.  If the command fails, fail the test case

6.  In the response check that Event Data Length is 0x6, NEA bit is cleared, Notification Class is non-zero and Supported Event Classes are identical to step 3. Otherwise fail the test case.

7.  Send Get Event Status Notification Command with the following values in the CDB.

    -   Notification Class Request = 0x7E (Operational Change, Power Management, External Request, Media, Multi-Host, Device Busy).

    -   Polled = 1

    -   Allocation Length equal to the size of the response header (4 bytes)

8.  If the command fails, fail the test case.

**Result:** The drive should respond to the GET EVENT STATUS NOTIFICATION command properly.

### <span id="INQUIRY_command"></span><span id="inquiry_command"></span><span id="INQUIRY_COMMAND"></span>INQUIRY command

**Description:** To validate if the drive supports the INQUIRY command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the INQUIRY command with allocation length equal 08h. Purpose: allow software to probe the required response buffer size.

2.  If the command succeeds, check the response for the additional length in the header. The additional length must be 32d or larger \[MMC5r04 6.9.2\].

3.  Send the INQUIRY command again with allocation length set to 5 bytes more than the additional length from step 2.

4.  If the command succeeds, ensure that response data fields match values specified in MMC5r04 table 320.

5.  Check that Vendor Identification, Product Identification and Product Revision Level are not null.

    -   Purpose: Basic identification by software.

6.  Check if the following values match:

    -   Device Type = 5

    -   Device Type Qualifier = 0

    -   Removable Media = 1

    -   Response Data Format = 2

    -   Hierarchy Support = 0

    -   Normal ACA = 0

    -   Protect = 0

    -   Third Party Copy = 0

    -   Target Port Group Support = 0

    -   Access Controls Coordinator = 0

    -   SCC Supported = 0

    -   Addr16 = 0

    -   Medium Changer = 0

    -   Multi Port = 0

    -   VS1 = 0

    -   Enclosure Services = 0

    -   BQue = 0

    -   VS2 = 0

    -   Command Queue = 0

    -   Linked Commands = 0

    -   Synchronous = 0

    -   Wide16 = 0

7.  Send the INQUIRY command with the following values in the CDB:

    -   EVPD = 0

    -   Allocation Length = 240

8.  Send the INQUIRY command with the following values in the CDB:

    -   EVPD = 1

    -   Allocation Length = 240

9.  If the command succeeds then compare the response from step 7 and step 8, if both are equal then fail the test case.

10. Send the INQUIRY command for a random number of times between 10 and 25 with random allocation lengths. If the command fails then fail the test case.

11. \[Optional\] Send the INQUIRY command with the data direction flag set to" to the device" and with the following values in the CDB

    -   EVPD = 0

    -   Allocation Length = 240

**Result:** The drive should respond to the INQUIRY command properly.

### <span id="MECHANISM_STATUS_command"></span><span id="mechanism_status_command"></span><span id="MECHANISM_STATUS_COMMAND"></span>MECHANISM STATUS command

**Description:** To validate if the drive supports the MECHANISM STATUS command

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the MECHANISM STATUS command with allocation length 0 bytes (data sense unspecified). If the command fails, print the sense key and fail the test case.

    -   Purpose: allow software to probe support of command

2.  Eject the Tray.

3.  Wait until the device return the sense data (Sense Key : 0x2, ASC: 0x3A, ASCQ: 0x02)

4.  Send the MECHANISM STATUS command with allocation length 8 bytes.

5.  Check that Door Open bit is 1b.

    -   Purpose: Allow software to detect if door is open or closed (open).

6.  Inject the tray

7.  Wait until the device is ready

8.  Send the MECHANISM STATUS command with allocation length 8 bytes.

9.  Check that Door Open bit is 0b.

    -   Purpose: Allow software to detect if door is open or closed (closed).

10. Create an 8 byte buffer and fill it with random data.

11. \[Optional\] Send the MECHANISM STATUS command with data direction flag set to "to the device" and with allocation length of 8 bytes. Pass the buffer from step 11 to the device.

**Result:** The drive should respond to the MECHANISM STATUS command properly

### <span id="MODE_SENSE_command"></span><span id="mode_sense_command"></span><span id="MODE_SENSE_COMMAND"></span>MODE SENSE command

**Description:** To validate if the drive supports the Mode Sense command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the MODE SENSE command with the following values in the CDB to get all the supported Mode Pages:

    -   Page Control = 0

    -   Disable Block Descriptors = 1

    -   Page Code = 0x3F

    -   Allocation Length = 0x8000

2.  Check the following values in the response:

    -   Block Descriptor Length in the mode parameters header is zero

    -   Page length for each mode page data is equal to the value documented in MMC5.

3.  Validate the Mode page data for each reported page

4.  Send the Mode Sense command for each reported page with the following values in the CDB:

    -   Page Control = 0

    -   Disable Block Descriptors = 1

    -   Allocation Length = Page Length reported by the drive in step 2

5.  Check the following values in the response:

    -   Block Descriptor Length in the mode parameters header is zero.

    -   Page code in the mode page header matches with the requested page code.

    -   Page length in the mode page header is equal to the value document in MMC5.

6.  Send the Mode Sense command with allocation length 0xFFF0

7.  Check the following values in the response:

    -   Block Descriptor Length in the mode parameters header is zero

    -   Page code in the mode page header matches with the requested page code

8.  Send the Mode Sense command with allocation length 0x0A

9.  Check if the response matches byte by byte up to the response size (0x0A) with the response for allocation length equal to 0xFFF0.

10. Send the Mode Sense command for a random number of times between 10 and 25 with random allocation lengths between 0x0A and 0xFFF0.

11. Check if the response matches byte by byte up to the response size (random value between 0x0A and 0xFFF0) with the response for allocation length equal to 0xFFF0.

12. \[Optional\] Send the MODE SENSE command with the data direction flag set to "to the device" and with the following values in the CDB to get all the supported Mode Pages:

    -   Page Control = 0

    -   Disable Block Descriptors = 1

    -   Page Code = 0x3F

    -   Allocation Length = 0x8000

**Result:** The drive should respond to the GET CONFIGURATION command properly

### <span id="PREVENT_ALLOW_MEDIUM_REMOVAL_command"></span><span id="prevent_allow_medium_removal_command"></span><span id="PREVENT_ALLOW_MEDIUM_REMOVAL_COMMAND"></span>PREVENT ALLOW MEDIUM REMOVAL command

**Description:** To validate if the drive supports the PREVENT ALLOW MEDIUM REMOVAL command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the PREVENT ALLOW MEDIUM REMOVAL command with prevent bit set to 1 and Persistent bit set to 0. This would lock the drive. If the command fails print the sense key and fail the test case.

2.  Send the start stop unit command with LocEj bit set to 1 and Immediate bit set to 0 and Start bit set to zero. This will try to eject the disc. If the drive doesn't reject the command with sense data 0x05 0x53, 0x02 then it is a failure.

3.  Send the Test Unit ready command and ensure it succeeds.

4.  Ask the user to press the eject button to eject the media.

5.  Send the Test Unit ready command and ensure it still succeeds (door should not open).

6.  Send the Prevent Allow Medium Removal command with prevent bit set to 0 and Persistent bit set to 0. This would unlock the drive. If the command fails print the sense key and fail the test case.

7.  Ask the user to press the eject button to eject the media

8.  Wait for the device to open the door - Send the Test Unit ready command, if the command succeeds then wait for 1 second and retry until it fails with (02/3A/02). Timeout after 30 seconds.

9.  If the drive supports auto loading mechanism then inject the tray back into the drive otherwise ask the user to insert the tray back into the drive.

10. Wait for the device to be ready

11. \[Optional\] Send the PREVENT ALLOW MEDIUM REMOVAL command with the data direction flag set to the "to the device" and pass the random data in a random size buffer.

**Result:** The drive should respond to the PREVENT ALLOW MEDIUM REMOVAL command properly.

### <span id="REQUEST_SENSE_command"></span><span id="request_sense_command"></span><span id="REQUEST_SENSE_COMMAND"></span>REQUEST SENSE command

**Description:** To validate if the drive supports the REQUEST SENSE command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the REQUEST SENSE command, with the descriptor bit set to zero and Allocation Length set to 252. The drive shall respond with the fixed format sense data.

2.  If the command fails print the sense key and fail the test case.

3.  If the response code is 0x70 or 0x71 the test passes otherwise the test fails.

4.  \[Optional\] Send the REQUEST SENSE command, with the data direction flag set to "to the device" and with the descriptor bit set to zero and Allocation Length set to 252. The drive shall respond with the fixed format sense data.

**Result:** The drive should respond to the REQUEST SENSE command properly.

### <span id="START_STOP_UNIT_command__EJECT___LOAD_PERFORMANCE"></span><span id="start_stop_unit_command__eject___load_performance"></span><span id="START_STOP_UNIT_COMMAND__EJECT___LOAD_PERFORMANCE"></span>START STOP UNIT command, EJECT & LOAD PERFORMANCE

**Description:** To validate if the drive supports the START STOP UNIT command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the START STOP UNIT command with the following values in the CDB

    -   Immediate = 0, LoadEject = 0, Start = 0, PowerConditions = 0

    -   Immediate = 0, LoadEject = 0, Start = 1, PowerConditions = 0

    -   Immediate = 1, LoadEject = 0, Start = 0, PowerConditions = 0

    -   Immediate = 1, LoadEject = 0, Start = 1, PowerConditions = 0

2.  The command shall succeed for each of this combination.

3.  If the drive supports ejecting the tray, then send the START STOP UNIT command with the following values in the CDB, to eject the tray

    -   Immediate = 1, LoadEject = 1, Start = 0, PowerConditions = 0

4.  Wait for the device to open the door - Send the TEST UNIT READY command, if the command succeeds then wait for 5 seconds and retry until it fails with (02/3A/02). Timeout after 10 seconds.

5.  If the drive supports loading the tray (auto inject), then send the START STOP UNIT command with the following values in the CDB, to inject the tray:

    -   Immediate = 1, LoadEject = 1, Start = 1, PowerConditions = 0

6.  If the drive doesn't support loading the tray then ask the user to insert the tray back into the drive.

7.  Wait for the device to be ready - Send the TEST UNIT READY command, if the command fails with a sense key then wait for 1 second and retry until it succeeds. Timeout after 30 seconds. PREMIUM LOGO: Time out: 20 seconds.

8.  Send the START STOP UNIT command with the following values in the CDB, to eject the tray:

    -   Immediate = 0, LoadEject = 1, Start = 0, PowerConditions = 0

9.  Wait for the device to open the door - Send the TEST UNIT READY command, if the command succeeds then wait for 1 second and retry until it fails with (02/3A/02). Timeout after 30 seconds.

10. Ask user to remove the media

11. If the drive supports loading the tray (auto inject), then send the START STOP UNIT command with the following values in the CDB, to inject the tray:

    -   Immediate = 0, LoadEject = 1, Start = 1, PowerConditions = 0

12. Ensure the command fails with Not Ready / Medium not present / Tray closed (02/3A/01)

13. If the drive supports ejecting the tray, then send the START STOP UNIT command with the following values in the CDB, to eject the tray:

    -   Immediate = 0, LoadEject = 1, Start = 0, PowerConditions = 0

14. Ask the user to place the media in the tray.

15. If the drive doesn't support loading the tray then ask the user to insert the tray back into the drive and wait until the device is ready. If the drive supports loading the tray (auto inject), then send the START STOP UNIT command with the following values in the CDB, to inject the tray and wait until the device is ready.

    -   Immediate = 0, LoadEject = 1, Start = 1, PowerConditions = 0

16. \[Optional\] Send the START STOP UNIT command with data direction flag set to "to the device". Send random size buffer with random data and with the following values in the CDB.

    -   Immediate = 0, LoadEject = 0, Start = 0, PowerConditions = 0

**Result:** The drive should respond to the START STOP UNIT command properly.

### <span id="TEST_UNIT_READY_command"></span><span id="test_unit_ready_command"></span><span id="TEST_UNIT_READY_COMMAND"></span>TEST UNIT READY command

**Description:** To validate if the drive supports the TEST UNIT READY command.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the TEST UNIT READY command.

2.  If the command fails print the sense key and fail the test case

3.  \[Optional\] Send the TEST UNIT READY command with data direction flag set to "to the device" and with random size buffer filled with random data.

**Result:** The drive should respond to the TEST UNIT READY command properly.

### <span id="GET_CONFIGURATION_command"></span><span id="get_configuration_command"></span><span id="GET_CONFIGURATION_COMMAND"></span>GET CONFIGURATION command

**Description:** To validate if the drive supports the GET CONFIGURATION command for the reported profile.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the GET CONFIGURATION command with response data length of 0 bytes (data sense unspecified). If the command fails, print the sense key and fail the test case.

    -   Purpose: allow software to probe support of command.

2.  Send the GET CONFIGURATION command with response data length of 4 bytes to get the feature header data length. If the command fails, print the sense key and fail the test case.

    -   Purpose: allow software to probe support of command.

3.  Send the GET CONFIGURATION command with response data length of 8 bytes (to get the header), RT=00b, Starting Feature Number=0000h. If the command fails or if the Current Profile equals 00h, print the sense key as appropriate and fail the test case.

    -   Purposes:

        -   allow software to probe the required response buffer size.

        -   allow software to probe current profile (a profile is current).

4.  If the command succeeds check the following in the response

    -   Data length in the header is non zero and it is four byte aligned

    -   Current profile number matches with media type loaded in the drive

5.  Send the GET CONFIGURATION command with response data length read at step 3, RT=00b, Starting Feature Number=0000h. Read the Current Profile, and then look for this profile code in the list of supported profiles. Ensure the current profile matches with the profile type of the inserted media. If the command fails or if the current profile is not reported current in the list of supported profiles, print the sense key as appropriate and fail the test case.

    -   Purpose: Ensure consistency of the information reported by the drive.

6.  Send the GET CONFIGURATION command again with RT=00b and with the correct data length returned by the device in step3 if length fits 2 bytes. If length exceeds 2 bytes, send the command with maximum data length for 2 bytes.

    -   Purpose: allow software to retrieve the entire list of features supported by the drive.

7.  If length exceeded 2 bytes, read the feature number for the last complete feature descriptor returned and issue additional GET CONFIGURATION command with RT=10b and with starting feature number equal to this feature number plus 1. Repeat operation until the data length returned in the feature header is equal or smaller to the allocated length. Concatenate the resulting feature descriptors for verification in step 10.

8.  For all commands succeeding at steps 3-6, check if the data length in the header of the response is multiple of 4 (4 byte aligned). Fail if it is not 4 byte aligned. Purpose: 4 bytes alignment is assumed by software.

9.  Additionally if the command(s) succeeded, check that each reported feature Version and Additional Length fields are equal or bigger than the respective values for the given feature in MMC-5 document. E.g.: Core Feature's version must be 0010b or higher and its additional length must be 8 or larger. Purpose: Ensure consistency of the information reported by the drive. If the removable medium feature is reported, the version number of it should be 1 as specified in GET CONFIGURATION command.

10. Additionally if the command(s) succeeded, check that each mandatory feature for reported supported profile is reported.

    -   Purpose: Ensure consistency of the meta-information reported by the drive.

11. Send the GET CONFIGURATION command with response data length of 20 bytes, RT=01b, Starting Feature Number=0010h (Random Readable Feature). If the command fails or if the Random Readable Feature descriptor is not returned, print the sense key as appropriate and fail the test case. Purpose: allow software to probe specific feature currency (current).

12. \[Optional\] Send the GET CONFIGURATION command with data direction flag set to "to the device" and with random size buffer filled with random data. The following values are set in the CDB:

    -   Allocation Length = Size of the buffer, Starting Feature Number=0000h, RT=00b

**Result:** The drive should properly implement the GET CONFIGURATION command for the applicable media types.

### <span id="GET_PERFORMANCE_command"></span><span id="get_performance_command"></span><span id="GET_PERFORMANCE_COMMAND"></span>GET PERFORMANCE command

**Description:** To validate if the drive supports the GET PERFORMANCE command for the reported profile.

**Applicable Media:** Any of the following media:

-   CD-R

-   CD-ROM

-   CD-RW

-   DVD+R

-   DVD+R Dual Layer

-   DVD+RW

-   DVD-RW Restricted Overwrite

-   DVD-RAM

-   DVD-R

-   DVD-R Dual Layer Seq

-   DVD-ROM

-   BD-R

-   BD-RE

-   BD-ROM

**Test Case Steps:**

1.  Send the GET CONFIGURATION command to the get the REAL TIME STREAMING feature. Check the response, if the Write Speed Performance Descriptor bit is set. If this is not set then the drive doesn't support Write speed descriptors. Skip steps 6 to 11 which validate the write speed descriptors.

2.  Send the GET PERFORMANCE command with the following values in the CDB to get zero nominal read performance descriptors

    -   Type = 0

    -   Starting LBA = 1

    -   Max Descriptors = 0

    -   Data Type = 0x10

3.  If the command fails print the sense key and fail the test case

4.  Send the GET PERFORMANCE command with the following values in the CDB to get one nominal read performance descriptor

    -   Type = 0

    -   Starting LBA = 1

    -   Max Descriptors = 1

    -   Data Type = 0x10

5.  If the command fails print the sense key and fail the test case

6.  Send the GET PERFORMANCE command with the following values in the CDB to get one nominal write performance descriptor.

    -   Type = 0

    -   Starting LBA = 1

    -   Max Descriptors = 1

    -   Data Type = 0x14

7.  If the command fails print the sense key and fail the test case

8.  Send the GET PERFORMANCE command with the following values in the CDB to get data length for the list of write speed descriptors

    -   Type = 3

    -   Starting LBA = 1

    -   Max Descriptors = 0

    -   Data Type = 0x14

9.  If the command fails print the sense key and fail the test case.

10. Send the GET PERFORMANCE command with the following values in the CDB to get the list of write speed descriptors

    -   Type = 3

    -   Starting LBA = 1

    -   Max Descriptors = 10

    -   Data Type = 0x14

11. If the command fails print the sense key and fail the test case.

12. \[Optional\] Send the GET PERFORMANCE command with data direction flag set to "to the device" and with random size buffer filled with random data. Set with the following values in the CDB to get zero nominal read performance descriptors.

    -   Type = 0

    -   Starting LBA = 1

    -   Max Descriptors = 0

    -   Data Type = 0x10

13. If the command fails print the sense key and fail the test case.

**Result:** The drive should properly implement the GET PERFORMANCE command for the applicable media types.

### <span id="READ_CAPACITY_command"></span><span id="read_capacity_command"></span><span id="READ_CAPACITY_COMMAND"></span>READ CAPACITY command

**Description:** To validate if the drive supports the READ CAPACITY command for the reported profile.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the READ CAPACITY command.

2.  If the command fails print the sense key and fail the test case.

3.  If the Block length in bytes is not 2048 then fail the test case.

4.  \[Optional\] Send the READ CAPACITY command with data direction flag set to "to the device" and with random size buffer filled with random data.

5.  If the command fails print the sense key and fail the test case.

**Result:** The drive should properly implement the READ CAPACITY command for the applicable media types.

### <span id="READ_BUFFER_CAPACITY_command"></span><span id="read_buffer_capacity_command"></span><span id="READ_BUFFER_CAPACITY_COMMAND"></span>READ BUFFER CAPACITY command

**Description:** To validate if the drive supports the READ BUFFER CAPACITY command for the reported profile.

**Applicable Media:** Any media supported by the device.

**Test Case Steps:**

1.  Send the GET CONFIGURATION command to the get the REAL TIME STREAMING feature. Check the response, if the Read Buffer Capacity Block (RBCB) bit is set. If this is not set then the drive doesn't support Read Buffer Capacity command. Skip the test case.

2.  Send the READ BUFFER CAPACITY command with block bit set to 0, and Allocation Length equal to the size of the Buffer Capacity Structure.

3.  If the command fails print the sense key and fail the test case.

4.  Repeat step 2 with Block bit set to 1.

5.  If the command fails print the sense key and fail the command.

6.  \[Optional\] Send the READ BUFFER CAPACITY command with data direction flag set to "to the device" and with random size buffer filled with random data and block bit set to zero.

7.  If the command fails print the sense key and fail the test case.

**Result:** The drive should properly implement the READ BUFFER CAPACITY command for the applicable media types.

### <span id="READ_DISC_INFORMATION_command"></span><span id="read_disc_information_command"></span><span id="READ_DISC_INFORMATION_COMMAND"></span>READ DISC INFORMATION command

**Description:** To validate if the drive supports the READ DISC INFORMATION command for the reported profile.

**Applicable Media:** Any of the following media:

-   DVD+R

-   DVD+RW

-   DVD-R

-   CD-R

-   CD-RW

**Test Case Steps:**

1.  Send the READ DISC INFORMATION command, with the allocation length of 2 to get the standard disc information size.

2.  If the command fails print the sense key and fail the test case.

3.  Get the disc information length from the response. If the length is less than the Standard Disc Information Block Size (34), then fail the test case.

4.  Send the READ DISC INFORMATION command, with the allocation length equal to the data length from step 3 plus 2.

5.  If the command fails print the sense key and fail the test case.

6.  \[Optional\] Send the READ DISC INFORMATION command with data direction flag set to "to the device" and with random size buffer filled with random data and Allocation length set to the size of the buffer.

**Result:** The drive should properly implement the READ DISC INFORMATION command for the applicable media types.

### <span id="READ_FORMAT_CAPACITIES_command"></span><span id="read_format_capacities_command"></span><span id="READ_FORMAT_CAPACITIES_COMMAND"></span>READ FORMAT CAPACITIES command

**Description:** To validate if the drive supports the READ FORMAT CAPACITIES command for the reported profile.

**Applicable Media:** Any of the following media:

-   DVD+RW

-   DVD-RW Restricted Overwrite

-   DVD-RAM

-   CD-RW

**Test Case Steps:**

1.  Send the READ FORMAT CAPACITIES command with Allocation Length equal to 4 (Capacity List Header).

2.  If the command fails print the sense key and fail the test case.

3.  Get the Capacity List Length from the response

4.  Send the READ FORMAT CAPACITIES command with Allocation Length equal to Capacity List Length + 4 (size of the Capacity List Header).

5.  If the command fails print the sense key and fail the test case.

6.  Check the response if the capacity list length is multiple of 8.

7.  \[Optional\] Send the READ FORMAT CAPACITIES command with data direction flag set to "to the device" and with random size buffer filled with random data and Allocation length set to the size of the buffer.

**Result:** The drive should properly implement the READ FORMAT CAPACITIES command for the applicable media types.

### <span id="READ_TOC_PMA_ATIP_command"></span><span id="read_toc_pma_atip_command"></span><span id="READ_TOC_PMA_ATIP_COMMAND"></span>READ TOC/PMA/ATIP command

**Description:** To validate if the drive supports the READ TOC/PMA/ATIP command for the reported profile.

**Applicable Media:** Any of the following media:

-   CD-ROM

-   DVD-ROM

-   BD-ROM

**Test Case Steps:**

1.  Send the READ TOC/PMA/ATIP command with the following values in the CDB.

    -   Format = 0, MSF = 0, Track Session Number = 1, Allocation Length = 4

2.  If the command fails print the sense key and fail the test case.

3.  \[Optional\] Send the READ TOC/PMA/ATIP command with data direction flag set to "to the device" and with buffer filled with random data and Allocation length set to the size of the buffer. Set the CDB with the following values:

    -   Format = 0, MSF = 0, Track Session Number = 1, Allocation Length = 4

**Result:** The drive should properly implement the READ TOC/PMA/ATIP command for the applicable media types

### <span id="SEND_OPC_INFORMATION_command"></span><span id="send_opc_information_command"></span><span id="SEND_OPC_INFORMATION_COMMAND"></span>SEND OPC INFORMATION command

**Description:** \[This content isn't available yet.\]

**Applicable Media:** Any of the following media:

-   DVD-RW Restricted Overwrite

-   DVD-R

-   CD-RW

-   CD-R

**Test Case Steps:**

1.  Send the SEND OPC INFORMATION command with DoOpc set to 1

2.  If the command fails print the sense key and fail the test case.

3.  \[Optional\] Send the SEND OPC INFORMATION command with DoOpc set to 1, data direction flag set to "to the device" and with random size buffer filled with random data. The Allocation length is set to the size of the buffer.

**Result:** The drive should properly implement the SEND OPC INFORMATION command for the applicable media types.

### <span id="SET_CD_SPEED_command"></span><span id="set_cd_speed_command"></span><span id="SET_CD_SPEED_COMMAND"></span>SET CD SPEED command

**Description:** To validate if the drive supports the SET CD SPEED command for the reported profile.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Send the GET CONFIGURATION command to the get the REAL TIME STREAMING feature. Check the response, if the Set CD Speed (SCS) bit is set. If this is not set then the drive doesn't support SET CD SPEED command. Skip the test case.

2.  Send the SET CD SPEED command, with the following values in the CDB.

    -   RotationalControl = 0, ReadSpeed = 0xFFFF, WriteSpeed = (((4\* 75 \* 2352) + 500) / 1000) If the command fails print the sense key and fail the test case

3.  \[Optional\] Send SET CD SPEED command with data direction flag set to "to the device" and with random size buffer filled with random data. Set the following values in the CDB.

    -   RotationalControl = 0, ReadSpeed = 0xFFFF, WriteSpeed = (((4\* 75 \* 2352) + 500) / 1000)

**Result:** The drive should properly implement the SET CD SPEED command for the applicable media types.

### <span id="READ10_command"></span><span id="read10_command"></span><span id="READ10_COMMAND"></span>READ10 command

**Description:** To validate if the drive supports the READ10 command for the reported profile.

**Applicable Media:** Any of the following media:

-   CD-ROM

-   DVD-ROM

**Test Case Steps:**

1.  Send READ TOC/PMA/ATIP command with Allocation Length equal the size of the READ TOC response header ( 4 bytes)

2.  Send READ TOC/PMA/ATIP command with Allocation Length equal the size of the READ TOC response header ( 4 bytes) + the Data Length from the Response Header from step 1.

3.  Check all the formatted Read TOC descriptors, if any of its control is set to 0x04

4.  If not found then fail the test case

5.  Otherwise get the track starting address from the formatted Toc track descriptor.

6.  Send the Read Capacity command with LBA field set to zero, to get the Block size.

7.  Send the Read Command with the Transfer Length set to zero and Starting LBA set to the LBA from step 5.

8.  Calculate the number of blocks to read

9.  If the LBA in the Read capacity response is less than the LBA from the step 5 then the number of blocks to read is set to 0

10. If the LBA in the Read capacity response is greater than the LBA from the step 5 then set the number of blocks to read equal to difference between the LBA from the read capacity response and the LBA from step 5. If that value is greater than 50, set the number of blocks to read to 50.

11. Set the Starting LBA in the read 10 CDB to the LBA from step 5

12. Send the read10 command with transfer length set to 1

13. Sleep for 10 milliseconds

14. Increment the starting LBA in the read 10 CDB

15. Repeat steps 12 to 14 until we read all the number of blocks.

16. \[Optional\] Send the READ10 command with data direction flag set to "to the device" and with random size buffer filled with random data. Set the following values in the CDB.

    -   TransferLength = 1, Starting LBA = Random LBA value in the LBA range of Number of LBAs from step 8 with starting LBA from the step 5

**Result:** The drive should properly implement the READ10 command for the applicable media types.

### <span id="Event_notification"></span><span id="event_notification"></span><span id="EVENT_NOTIFICATION"></span>Event notification

**Description:** To validate if the device event notification are properly reported to the windows PNP.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  If BusType field of the drive's STORAGE\_ADAPTER\_DESCRIPTOR structure is set to BusTypeSata then send IOCTL\_ATA\_PASS\_THROUGH with request for Identify Packet Device Information data. In the response check that bit 5 of word 78 (Asynchronous Notification feature is supported) and bit 5 of word 79 (Asynchronous Notification feature is enabled) are both set. Otherwise fail the test

2.  Register for Operational Change event.

3.  Check if the media is present.

4.  If the media is present, eject media.

5.  Wait for the MEDIA REMOVAL event. If the event is not generated within 60 seconds timeout then fail the test case.

6.  Inject the media to the drive.

7.  Wait for the MEDIA ARRIVAL event. If the event is not generated within 60 seconds timeout then fail the test case.

**Result:** The drive should properly implement the event notifications.

### <span id="Write_tests"></span><span id="write_tests"></span><span id="WRITE_TESTS"></span>Write tests

**Description:** Validates the write capabilities of the drive for the data content in the context of IMAPI. The device is tested with various write speeds reported by the drive. The test also validates the multisession capabilities of the device is applicable for the inserted media

**Applicable Media:** Any of the following media (depends on the drive operation):

-   Sequential writing:

    -   CD-R

    -   CD-RW

    -   DVD+R

    -   DVD-R

    -   DVD-RAM

    -   BD-R

    -   BD-RE

-   Restricted overwrite:

    -   DVD-RW

-   Packet mode:

    -   DVD+RW

-   Multisession:

    -   CD-R

    -   CD-RW

    -   DVD-R

    -   DVD+R

    -   BD-R

**Test Case Steps:**

1.  Ask the user to insert blank media.

2.  Call the API IDiscFormat2Data::get\_CurrentMediaStatus to check if the media is blank.

3.  If the media is not blank and if it is one of the following rewriteable media type, then erase the media by sending the blank command with a minimal blank option.

    -   CD-RW

    -   DVD-RW Sequential Recording

    -   DVD-RW Restricted Overwrite

    -   DVD+RW

    -   DVD-RAM

    -   BD-RE

4.  If the media is not a rewritable media then ask the user to insert the blank media. Retry this for 3 times, otherwise fail the test case.

5.  If the media is not a rewritable media then ask the user to insert the blank media. Retry this for 3 times, otherwise fail the test case.

6.  Get the list of Write Speed Descriptors by calling the API IDiscFormat2Data::get\_SupportedWriteSpeedDescriptors.

7.  Randomize the order of the reported write speeds

8.  Set the Write Speed by calling the API IDiscFormat2Data::SetWriteSpeed with one of the write speeds from step 6.

9.  Create a random data size with the range of 10% of the available space on the media. Fill the buffer with random data.

10. Get the number of free blocks on the disc using the API IDiscFormat2Data::get\_FreeSectorsOnMedia.

11. Get the next writable address using the API IDiscFormat2Data::get\_NextWritableAddress.

12. Write the data buffer from step 8 using IDiscFormat2Data::Write.

13. If the drive supports Auto eject-inject mechanism then eject and inject the media into the tray.

14. If the media is not DVD-RW, DVD+RW, DVD-RAM, BD-RE then:

    -   Get the number of free blocks on the disc using the API IDiscFormat2Data::get\_FreeSectorsOnMedia.

    -   Check if the number of free sectors is less than the value from step 9 by the size of write data in step 8.

    -   Get the next writable address using the API IDiscFormat2Data::get\_NextWritableAddress.

    -   Check next writable address is greater than the next writable address from step 10 by the size of the write data in step 8.

    -   Read data from the disc and compare if it matches with the data written to the media in step 11.

15. Get the last Track Information

16. If the media is not DVD-RW then check if the Logical Track Size if greater than or equal to size of the data we wrote.

17. Check if the Logical track number is correct.

18. Get the Write parameters mode page.

19. Check if the Track information reported by the drive is not Packet/Incremental if the Write parameters mode page reports as Fixed packet.

20. Read disc information and check if the number of session matches.

21. If the media is not DVD-RW, DVD+RW and DVD-RAM then repeat steps 7 to 19 for each write speed. If the drive returned only one write speed then repeat steps 7 to 19 one more time to add one more session to the disc for validating the multisession capabilities.

**Result:** The drive should be capable of burning the data in the context of IMAPI.

### <span id="AUDIO_MEDIA__WRITE_AUDIO_TRACKS_"></span><span id="audio_media__write_audio_tracks_"></span>AUDIO MEDIA (WRITE AUDIO TRACKS)

**Description:** Validate the write capabilities of the drive for the audio content in the context of IMAPI.

**Applicable Media:** Any of the following media:

-   CD-R

-   CD-RW

**Test Case Steps:**

1.  If the media is not blank and if it is CD-RW media type, then erase the media by sending the blank command with a minimal blank option.

2.  If the media is not a rewritable media then ask the user to insert the blank media. Retry this for 3 times, otherwise fail the test case.

3.  Lock the Media for Exclusive Access by calling DiscFormat2TrackAtOnce::PrepareMedia.

4.  Get the list of Write Speed Descriptors by calling the API IDiscFormat2TrackAtOnce::get\_SupportedWriteSpeeds.

5.  Choose random number of audio tracks between 3 and 10.

6.  Randomize the order of the reported write speeds.

7.  Set the Write Speed by calling the API IDiscFormat2TrackAtOnce::SetWriteSpeed from step 1.

8.  Get the number of free blocks on the disc using the API IDiscFormat2Data::get\_FreeSectorsOnMedia.

9.  Create audio data of random size from 1 minute audio data to 10 minute audio data. The size of the data should be a multiple of 2352.

10. Add the audio data stream to the IDiscFormat2TrackAtOnce::AddAudioTrack.

11. Get the last track Information

12. Check if the Logical track size if greater than or equal to size of the audio track we wrote.

13. Check if the Logical track number is correct

14. Get the number of free sectors on the media by calling IDiscFormat2TrackAtOnce::FreeSectorsOnMedia.

15. Check if the number of free sectors from step 14 is less than value from step 8 by the size of the audio track written to the media.

16. Repeat steps 5 to 15 for the number audio tracks from step 5

17. Get the Write parameters mode page

18. Check if the Track information reported by the drive is not Packet/Incremental if the Write parameters mode page reports as Fixed packet

19. Repeat steps 1 to 18 for each Write Speed.

20. If the drive supports Auto eject-inject mechanism then eject and inject the media into the tray.

**Result:** The drive should be capable of burning the audio media in the context of IMAPI.

### <span id="Blank"></span><span id="blank"></span><span id="BLANK"></span>Blank

**Description:** Validates the format/blank capabilities of the drive in the context of IMAPI.

**Applicable Media:** Any of the following media:

-   CD-RW

-   DVD+RW

-   DVD-RW Restricted Overwrite

-   BD-RE

**Test Case Steps:**

1.  Check if the media is one of the following read write media type by calling the API IDiscFormat2Data::CurrentPhysicalMediaType

    -   CD-RW

    -   DVD-RW

    -   DVD+RW

2.  If the media is not one of the read write media type then skip the test case.

3.  Check if the media is a blank media by calling the API IDiscFormat2Erase::MediaPhysicallyBlank.

4.  If the media is note blank, go to step 7.

5.  Create 25MB random data stream.

6.  Write the data stream to the disc using the API IDiscFormat2Data::Write.

7.  Check if the drive reports the media as non-blank media by calling the IDiscFormat2Data::get\_CurrentMediaStatus API.

8.  If the drive still reports media as blank then fail the test case

9.  Implement Erase Event Handler DDiscFormat2EraseEvents::Update.

10. Call the API IDiscFormat2Erase::put\_FullErase and set the erase option to false, so that it will do a minimal blank.

11. Send the blank command using the IDiscFormat2Erase::EraseMedia API.

12. Call the API IDiscFormat2Data::get\_CurrentMediaStatus to check if the media is blank.

13. Read disc information and check if the

    -   Number of sessions reported is 1.

    -   The first track in the last session is 1.

    -   The last track in the last session is 1.

14. Call the API IDiscFormat2Erase::put\_FullErase and set the erase option to full blank. Repeat steps 9 to 14.

**Result:** The drive should be capable of formatting the media in the context of IMAPI.

### <span id="Write_Dual-layer_media"></span><span id="write_dual-layer_media"></span><span id="WRITE_DUAL-LAYER_MEDIA"></span>Write Dual-layer media

**Description:** Validates the write capabilities of the for the dual layer media in the context of IMAPI. The device is tested with various write speeds reported by the drive.

**Applicable Media:** Any of the following media:

-   DVD+R DL

-   DVD-R DL

**Test Case Steps:**

1. Ask the user to insert blank media.

2. Call the API IDiscFormat2Data::get\_CurrentMediaStatus to check if the media is blank

3. If the media is not a rewritable media then ask the user to insert the blank media. Retry this for 3 times, otherwise fail the test case.

4. Get the list of Write Speed Descriptors by calling the API IDiscFormat2Data :: get\_SupportedWriteSpeedDescriptors.

5. Randomize the order of the reported write speeds

6. Set the Write Speed by calling the API IDiscFormat2Data::SetWriteSpeed with one of the write speeds from step 5.

7. Create a random data stream of random size up to 50% of the available space on the media. Fill the buffer with random data

8. Write the data buffer from step 7 using IDiscFormat2Data :: Write.

9. If the drive supports auto eject-inject mechanism then eject and inject the media into the tray.

10. Read data from the disc and compare if it matches with the data written to the media in step 9.

11. Get the last Track Information.

12. Check if the Logical Track Size if greater than or equal to size of the data we wrote.

13. Check if the Logical track number is correct

14. Get the Write parameters mode page.

15. Check if the Track information reported by the drive is not Packet/Incremental if the Write parameters mode page reports as Fixed packet.

16. Read disc information and check if the number of session matches.

17. Repeat steps 8 to 16 with random data stream of random size up to 100% of the available space on the media.

    > [!WARNING]
    > 
    > These last steps are to test if the drive is able to write the data on the dual layer properly.



**Result:** The drive should be capable of burning the data to both layers of the Dual Layer media in the context of IMAPI.

### <span id="Read-only_drive"></span><span id="read-only_drive"></span><span id="READ-ONLY_DRIVE"></span>Read-only drive

**Description:** Test the read capability of a read only drive on a open (append able) and closed (finalized) disc.

> [!WARNING]
> 
> This test case requires a secondary writer drive for creating the test data disc for the corresponding test profile.



**Applicable Media:** Any of the following media:

-   CD-ROM

-   DVD-ROM

-   BD-ROM

**Test Case Steps:**

1.  Eject the writer drive tray.

2.  If the test profile is

    -   CD-ROM ask the user to insert CD-R/CD-RW in the writer drive.

    -   DVD-ROM ask the user to insert DVD+R/DVD-R/DVD+RW/DVD-RAM in the writer drive.

    -   BD-ROM ask the user to insert BD-R/ BD-RE in the writer drive.

3.  Inject the writer drive tray.

4.  Get the list of Write Speed Descriptors by calling the API IDiscFormat2Data :: get\_SupportedWriteSpeedDescriptors.

5.  Create a random data stream of random size up to 10% of the available space on the media. Fill the buffer with random data.

6.  Set the Write Speed by calling the API IDiscFormat2Data::SetWriteSpeed with the first write speed descriptor value from step 4.

7.  Write the data buffer from step 5 using IDiscFormat2Data::Write to the media in the writer drive.

8.  Eject the writer drive tray if it supports auto eject mechanism. Otherwise ask the user to press the eject button

9.  Eject the test drive tray if it supports auto eject mechanism eject the tray otherwise ask the user to press the eject button.

10. Ask the use to remove the media from the writer drive and place it in the test drive.

11. Inject the writer drive tray if it supports auto inject (loading the tray) mechanism. Otherwise ask the user to insert the tray into the drive.

12. Inject the test drive tray if it supports auto inject (loading the tray) mechanism. Otherwise ask the user to insert the tray into the drive.

13. Read data from the test drive disc and compare if it matches with the data written to the media in step 7.

14. Set the IDiscFormat2Data::ForceMediaToBeClosed to true and Repeat steps 1 to 13 to validate the test drive on a finalized disc.

**Result:** The drive should be capable of reading both the closed and open media.

### <span id="Drive_serial_number"></span><span id="drive_serial_number"></span><span id="DRIVE_SERIAL_NUMBER"></span>Drive serial number

**Description:** Validates that the drive serial number returned by the test drive is in compliance with the MMC/Mt. Fuji specification standards.

> [!WARNING]
> 
> This test case requires two identical drives to validate if both drives return unique serial numbers. One primary test device and the other one is a secondary test drive.



**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1. Send the INQUIRY command to the primary test device with the allocation length equal 05h.

2. If the command succeeds, get the additional length value from the response header.

3. Send the INQUIRY command again to the primary device with allocation length set to 5 bytes more than the additional length from step 2.

4. If the command succeeds get the Vendor Identification, Product Identification and Product Revision Level.

5. Repeat the step 1 to 4 for the secondary drive and get the Vendor Identification, Product Identification and Product Revision Level.

6. Compare the Vendor Identification, Product Identification and Product Revision Level values from step 4 and step 5. If they do not match then fail the test case.

   > [!WARNING]
   > 
   > This is to make sure both the test drives are identical



7. Send the GET CONFIGURATION command to the primary test drive to get the LOGICAL UNIT SERIAL NUMBER feature with allocation length equal to the size of the LOGICAL UNIT SERIAL NUMBER feature descriptor.

8. Check the response if the feature code matches with the LOGICAL UNIT SERIAL NUMBER feature code. Get the additional length.

9. Send the GET CONFIGURATION command to the primary test drive to get the LOGICAL UNIT SERIAL NUMBER feature with allocation length equal to the size of the LOGICAL UNIT SERIAL NUMBER feature descriptor plus the required additional length reported in step 8.

10. Check the following in the response:

    -   The feature code matches with the LOGICAL UNIT SERIAL NUMBER feature code.

    -   The reported serial number data is in ASCII.

    -   Data is padded.

    -   No data after padding.

11. Repeat 7 to 9 for the secondary test device and get the drive serial number.

12. Compare the drive serial numbers from step 10 and step 11. The drives are expected to return unique serial numbers. If both the serial numbers are equal then fail the test case.

**Result:** The drive should return a unique serial number and that number should be in compliance with the MMC/Mt. Fuji standards.

### <span id="Real-time_streaming"></span><span id="real-time_streaming"></span><span id="REAL-TIME_STREAMING"></span>Real-time streaming

**Description:** Validates that the real-time streaming capabilities of the drive for the data content in the context of cdrom.sys driver. The device is tested with various read and write speeds reported by the drive.

**Applicable Media:** Any media supported by the device

**Test Case Steps:**

1.  Ask the user to insert media.

2.  If media is not writable or rewritable proceed to reading test at step 13.

3.  Call the API IDiscFormat2Data::get\_CurrentMediaStatus to check if the media is blank.

4.  If the media is not blank and if it is one of the following rewritable media type, then erase the media by sending the blank command with a minimal blank option.

    -   CD-RW

    -   DVD-RW Sequential Recording

    -   DVD-RW Restricted Overwrite

    -   DVD+RW

    -   DVD-RAM

    -   BD-RE

5.  If the media is not a rewritable media then ask the user to insert the blank media. Retry this for 3 times, otherwise fail the test case.

6.  Send GET CONFIGURATION command with request for REAL TIME STREAMING feature. If it is not successful or Current bit is not set fail the test.

7.  If either Stream Writing (SW) bit or Write Speed Performance Descriptor (WSPD) bit of REAL TIME STREAMING feature response is not set then fail the test.

8.  Send GET PERFORMANCE command with request for Write Speed Descriptors and build and array of supported write speeds. If the command is not successful fail the test.

9.  Shuffle the write speed array.

10. IF free media size is over 10% of its full capacity call DeviceIoControl with IOCTL\_CDROM\_SET\_SPEED and CDROM\_SET\_STREAMING structure supplied for the next write speed. Write random data up to 10% of full capacity and measure the speed (refer to the corresponding section in this document for measuring procedure description).

11. Repeat step 10 as long as possible. If all write speeds are probed shuffle the speed array and set next write speed to the beginning.

12. Send CLOSE TRACK SESSION commands to finalize the media

13. If Write Speed Performance Descriptor (WSPD) bit of REAL TIME STREAMING feature response is set then send GET PERFORMANCE command with request for Write Speed Descriptors and build an array of supported read speeds otherwise send GET PERFORMANCE command with request for Performance data with Tolerance bits set to 10b (nominal) and for the read speeds select the lowest value of Start Performance and End Performance fields in the response. If either of the commands I not successful fail the test.

14. Shuffle the read speed array.

15. Set the read length to size of the first track on media.

16. For each read speed call DeviceIoControl with IOCTL\_CDROM\_SET\_SPEED and CDROM\_SET\_STREAMING structure supplied for the next read speed. Read the whole data recorded on media in chunks of 10% of media capacity (or at least 5 MB if media has less than 50 MB of data) and measure the speed of each chunk. If the actual speed of any chunk is below the requested speed for any of the chunks mark the test failed.

**Result:** The drive should be capable of operating in real-time streaming mode.

### <span id="Write_speed_Measurement"></span><span id="write_speed_measurement"></span><span id="WRITE_SPEED_MEASUREMENT"></span>Write speed Measurement

The test queries the device and gets the supported write speeds for the test media. Then it will try to validate the write scenario for all the reported write speeds. The test expects the calculated write speeds for each write scenario is close to the write speed set to the drive. The test allows 10% tolerance for the measured write speed. The test validates the write speed as below.

The test writes data to the media and monitors the amount of data being written. It excludes the timing for the initial 10% written data the final 10% written data. It measures the timing only for the middle 80% data and calculates the speed for that data and adds 10% tolerance to that value. So, if 'x' is the calculated the speed for the middle 80% data then the final calculated speed is 1.1x. The test expects this value to be greater than or equal to the speed set to the drive before beginning the write.

The test excludes the initial 10% of data written timing to allow the drive to prepare for writing. The final 10% data timing is excluded to allow the drive to do the proper cleanup for the data written to the media.

### <span id="Audio_media_gapless_raw_recordings"></span><span id="audio_media_gapless_raw_recordings"></span><span id="AUDIO_MEDIA_GAPLESS_RAW_RECORDINGS"></span>Audio media gapless raw recordings

**Description:** Validates the write capabilities of the drive for the gapless raw audio content in the context of IMAPI

**Applicable Media:** Any of the following media:

-   CD-R

-   CD-RW

**Test Case Steps:**

1.  Check if the drive with media inserted supports gapless raw recording or not. If it's not supported, testing will fail.

2.  Check the sector types supported by test drive.

3.  For each sector type supported by test drive, complete steps 4 through 9

4.  Create the raw image.

5.  Set correct sector type and create the result stream for the raw image.

6.  Determine whether the raw image is gapless or not.

7.  Randomly choose a write speed and set it to be the burning speed. Set the requested sector type to be the one that has been set for the raw image. Write the stream of the raw image to the media and watch the progress. Calculate the speed of burning and print the throughput.

8.  Determine whether the writing is successful by checking each logical track information. Check if the track is audio track, if the track size is correct, and if the size of the last logical track number plus its start address is equal to the start address of the lead out of the disc. If any of the conditions returns false, testing will fail. Otherwise, it will pass.

9.  Do a raw reading for the media. For each track, check if the track is audio. If it's not, fail the testing, because the recording already ensured that the tracks are audio tracks. Calculate the start offset and end offset of the track. Do the reading for the track starting from the start offset and ending at the end offset of the track. If an error occurs during the reading process, fail the testing;

**Result:** The drive should be able to burn the gapless raw audio image in the context of IMAPI.

### <span id="Command_usage"></span><span id="command_usage"></span><span id="COMMAND_USAGE"></span>Command usage

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><strong>OpticalLogoTest.exe /drive [StorageDriveLetter]:\ /log [log] [AdditionalParams] /profile [profile] /RunTestCaseTypes [RunTestCaseTypes]</strong></p></td>
<td><p>Runs the test.</p></td>
</tr>
</tbody>
</table>

> [!NOTE]
> 
> For command-line help for this test binary, type **/h**.



### <span id="Command_syntax"></span><span id="command_syntax"></span><span id="COMMAND_SYNTAX"></span>Command syntax

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Command option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>drive</p></td>
<td><p>Test optical device drive letter.</p>
<p>Example: /drive e:&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>adapter</p></td>
<td><p>path (used for adapter test).</p>
<p>Example: /adapter &amp;quot;PCI\VEN_8086&amp;DEV_27DF&amp;SUBSYS_01AD1028&amp;REV_01\3&amp;172E68DD&amp;0&amp;F9&amp;quot;</p></td>
</tr>
<tr class="odd">
<td><p>PrimaryTestDrive</p></td>
<td><p>Test optical device drive letter.</p>
<p>Example: /PrimaryTestDrive e:&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>SecondaryTestDrive</p></td>
<td><p>Secondary optical test device drive letter.</p>
<p>Example: /Secondary Test Drive f:&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>WriterDrive</p></td>
<td><p>Drive letter of the Writer that needs to be used for testing read-only drives.</p>
<p>Example: /WriterDrive f:&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>PrimaryDriveTray</p></td>
<td><p>Primary optical device tray capabilities.</p>
<p>Example: /PrimaryDriveTray SupportsEjectInject</p></td>
</tr>
<tr class="odd">
<td><p>SecondaryDriveTray</p></td>
<td><p>Secondary optical device tray capabilities.</p>
<p>Example: /SecondaryDriveTray SupportsEjectInject</p></td>
</tr>
<tr class="even">
<td><p>WriterDriveTray</p></td>
<td><p>Writer drive tray capabilities.</p>
<p>Example: /WriterDriveTray SupportsEjectInject</p></td>
</tr>
<tr class="odd">
<td><p>profile</p></td>
<td><p>Run test cases specified profiles. Profile ID should be in decimal and comma separated without spaces.</p>
<p>Example: /profile 9,10,16</p></td>
</tr>
<tr class="even">
<td><p>seed</p></td>
<td><p>Seed value for generating random test data.</p>
<p>Example: /seed 1000</p></td>
</tr>
<tr class="odd">
<td><p>RunTestCaseTypes</p></td>
<td><p>Runs only the category of test cases.</p>
<p>Example: /RunTestCaseTypes device</p></td>
</tr>
<tr class="even">
<td><p>RunTestCase</p></td>
<td><p>Runs only this test case.</p>
<p>Example: /RunTestCase Inquiry</p></td>
</tr>
<tr class="odd">
<td><p>Automation</p></td>
<td><p>Run in automation mode using the robot to change the media.</p>
<p>Example: /Automation</p></td>
</tr>
<tr class="even">
<td><p>AutomationConfigFile</p></td>
<td><p>The configuration file used to specify bin location for media.</p>
<p>Example: /AutomationConfigFile OpticalLogoTest.exe.config</p></td>
</tr>
<tr class="odd">
<td><p>Calibrate</p></td>
<td><p>Calibrate the robot used to change the media.</p>
<p>Example: /Calibrate</p></td>
</tr>
<tr class="even">
<td><p>logo</p></td>
<td><p>The level of certification requirements to test.</p>
<p>Example: /logo basic or /logo premium</p></td>
</tr>
<tr class="odd">
<td><p>ReuseMedia</p></td>
<td><p>Reuse the non-blank media for testing. The test will not expect the media to be blank if the multisession is supported for that media. This option is for testing only. Not allowed for certification.</p>
<p>Example: /ReuseMedia</p></td>
</tr>
<tr class="even">
<td><p>SkipFullBlank</p></td>
<td><p>Skip the full blank scenario and test only minimal blank.</p>
<p>Example: /SkipFullBlank</p></td>
</tr>
<tr class="odd">
<td><p>SkipManualTestCases</p></td>
<td><p>Skip test cases that needs manual interaction.</p>
<p>Example: /SkipManualTestCases</p></td>
</tr>
<tr class="even">
<td><p>RunDataDirectionFlagScenario</p></td>
<td><p>Validate the commands with an incorrect data direction flag.</p>
<p>Example: /RunDataDirectionFlagScenario</p></td>
</tr>
<tr class="odd">
<td><p>Debugger</p></td>
<td><p>Prompts to attach debugger which gives time to allow the debugger to be attached before further executing the program.</p>
<p>Example: /Debugger</p></td>
</tr>
<tr class="even">
<td><p>Verbosity</p></td>
<td><p>Logging verbosity.</p>
<p>Example: /Verbosity Verbose</p></td>
</tr>
<tr class="odd">
<td><p>log</p></td>
<td><p>Log file name</p>
<p>Default value: OpticalLogoTest.wtl</p>
<p>Example: /log mytestlog.wtl</p></td>
</tr>
<tr class="even">
<td><p>EnableImapiv2Trace</p></td>
<td><p>Enable IMAPIv2 software trace.</p>
<p>Example: /EnableImapiv2Trace</p></td>
</tr>
<tr class="odd">
<td><p>Imapiv2TraceGuidsFile</p></td>
<td><p>IMAPIv2 trace GUIDs file that has the entire list of component GUIDs for which the traces need to be logged</p>
<p>Default value: imapiv2-guids.txt</p>
<p>Example: /IMAPIv2TraceGuidsFile imapiv2-guids.txt</p></td>
</tr>
<tr class="even">
<td><p>Imapiv2TraceLogFile</p></td>
<td><p>IMAPIv2 output trace log file.</p>
<p>Default value: imapiv2-tracelog.etl</p>
<p>Example: /IMAPIv2TraceLogFile imapiv2-tracelog.etl</p></td>
</tr>
<tr class="odd">
<td><p>cmdPerfTraceAnalysis</p></td>
<td><p>Run command performance analysis.</p>
<p>Example: /cmdPerfTraceAnalysis Always</p></td>
</tr>
<tr class="even">
<td><p>cmdPerfTraceGuidsFile</p></td>
<td><p>Performance trace GUIDs file that has the GUIDs of components that trace performance data</p>
<p>Default value: perf-guids.txt</p>
<p>Example: /cmdPerfTraceGuidsFile perf-guids.txt</p></td>
</tr>
<tr class="odd">
<td><p>cmdPerfTraceLogFile</p></td>
<td><p>Performance output trace log file</p>
<p>Default value: perf-tracelog.etl</p>
<p>Example: /cmdPerfTraceLogFile perf-tracelog.etl</p></td>
</tr>
<tr class="even">
<td><p>cmdPerfTraceTmfFile</p></td>
<td><p>Performance trace format description file.</p>
<p>Example: /cmdPerfTraceTmfFile perf-tracelog.tmf</p></td>
</tr>
</tbody>
</table>



### <span id="File_list"></span><span id="file_list"></span><span id="FILE_LIST"></span>File list

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Location</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>ataportlogotrace.tmf</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\optical\setup\tracing&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>autoloader.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\optical\autoloader&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>DataPacket.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>DeviceTestCases.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>DiscManagerLib.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>microsoft.storage.imapi.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\interop\imapi&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>ModularTestCase.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>OpticalLogoTest.exe</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>OpticalTestHarness.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>OpticalTestLib.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>ProfileTestCases.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>ScenarioTestCases.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>ScsiLib.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>storageinteroputil.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\interop\utils&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>tracefmt.exe</p></td>
<td><p><em>&lt;[osbinroot]&gt;</em>\idw&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>storagedevices.dll</p></td>
<td><p><em>&lt;[testbinroot]&gt;</em>\nttest\driverstest\storage\wdk&lt;/p&gt;</td>
</tr>
<tr class="odd">
<td><p>TraceLib.dll</p></td>
<td><p><em>&lt;[osbinroot]&gt;</em>\nttest\driverstest\storage\wdk\optical\test&lt;/p&gt;</td>
</tr>
<tr class="even">
<td><p>tracelog.exe</p></td>
<td><p><em>&lt;[osbinroot]&gt;</em>\idw&lt;/p&gt;</td>
</tr>
</tbody>
</table>



### <span id="Parameters"></span><span id="parameters"></span><span id="PARAMETERS"></span>Parameters

| Parameter name         | Parameter description                      |
|------------------------|--------------------------------------------|
| **StorageDriveLetter** | Test device drive letter                   |
| **profile**            |                                            |
| **LLU\_NetAccessOnly** | User account for accessing test fileshare. |
| **LLU\_LclAdminUsr**   | User account for running the test.         |
| **WDKDeviceID**        | Instance path of device to test            |
| **log**                |                                            |
| **RunTestCaseTypes**   |                                            |
| **AdditionalParams**   |                                            |












